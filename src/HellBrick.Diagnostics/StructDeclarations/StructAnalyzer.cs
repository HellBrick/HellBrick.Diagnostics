using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using HellBrick.Diagnostics.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace HellBrick.Diagnostics.StructDeclarations
{
	[DiagnosticAnalyzer( LanguageNames.CSharp )]
	public class StructAnalyzer : DiagnosticAnalyzer
	{
		private static readonly ImmutableArray<SyntaxKind> _syntaxKinds = new SyntaxKind[] { SyntaxKind.StructDeclaration }.ToImmutableArray();

		private static readonly ImmutableArray<IStructSyntaxNodeAnalyzer> _analyzers
			= new IStructSyntaxNodeAnalyzer[]
			{
				new ReadOnlyStructFieldsAnalyzer(),
				new ReadOnlyStructPropertyAnalyzer(),
				new StructEquatabilityAnalyzer()
			}
			.ToImmutableArray();

		public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get; }
			= _analyzers
			.SelectMany( a => a.SupportedDiagnostics )
			.ToImmutableArray();

		public override void Initialize( AnalysisContext context )
			=> context
			.RegisterSyntaxNodeAction( syntaxNodeContext => AnalyzeSyntaxNode( syntaxNodeContext ), _syntaxKinds );

		private static void AnalyzeSyntaxNode( SyntaxNodeAnalysisContext syntaxNodeContext )
		{
			if ( syntaxNodeContext.Node.Ancestors().Last().IsAutoGenerated() )
				return;

			StructDeclarationSyntax structDeclaration = syntaxNodeContext.Node as StructDeclarationSyntax;
			ITypeSymbol structType = syntaxNodeContext.SemanticModel.GetDeclaredSymbol( structDeclaration );

			foreach ( IStructSyntaxNodeAnalyzer analyzer in _analyzers )
				analyzer.AnalyzeStructSyntaxNode( structDeclaration, structType, syntaxNodeContext );
		}
	}
}
